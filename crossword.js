// Valentine's Crossword Puzzle
// Layout generated by crossword-layout-generator

// Set to true to skip directly to the reveal screen (for testing)
const DEBUG_SHOW_REVEAL = false;

const GRID_COLS = 33;
const GRID_ROWS = 22;

// Words from the generated layout
const words = [
    {
        word: "WILLYOUBEMYVALENTINE",
        clue: "The question this puzzle is really asking...",
        row: 10,
        col: 9,
        direction: "across",
        number: 1
    },
    {
        word: "BARRIOCHINO",
        clue: "First date spot",
        row: 12,
        col: 0,
        direction: "across",
        number: 2
    },
    {
        word: "CRUNCHFACTOR",
        clue: "The dream Food Network show you want to create",
        row: 17,
        col: 16,
        direction: "across",
        number: 3
    },
    {
        word: "WESTVILLAGE",
        clue: "Neighborhood where San Sabino is located",
        row: 15,
        col: 18,
        direction: "across",
        number: 4
    },
    {
        word: "FISHCHEEKS",
        clue: "Favorite crustacean dish spot in the city",
        row: 7,
        col: 7,
        direction: "down",
        number: 5
    },
    {
        word: "MARIOPARTY",
        clue: "Video game we love to play together",
        row: 8,
        col: 4,
        direction: "across",
        number: 6
    },
    {
        word: "KEYLIMEPIE",
        clue: "Our favorite dessert in Red Hook",
        row: 12,
        col: 22,
        direction: "across",
        number: 7
    },
    {
        word: "MARGARITAS",
        clue: "What we had for our first date",
        row: 12,
        col: 27,
        direction: "down",
        number: 8
    },
    {
        word: "SANSABINO",
        clue: "Favorite seafood restaurant",
        row: 4,
        col: 10,
        direction: "down",
        number: 9
    },
    {
        word: "LIMANTOUR",
        clue: "Our favorite cocktail bar in Mexico City",
        row: 3,
        col: 21,
        direction: "across",
        number: 10
    },
    {
        word: "LEITAO",
        clue: "Portuguese restaurant in NYC we enjoyed a lot",
        row: 3,
        col: 21,
        direction: "down",
        number: 10
    },
    {
        word: "VIACAROTA",
        clue: "Italian restaurant where they refused to give us sauce for our calamari",
        row: 6,
        col: 14,
        direction: "across",
        number: 11
    },
    {
        word: "SCALLOPS",
        clue: "The dish we made on our first Valentine's Day",
        row: 6,
        col: 25,
        direction: "across",
        number: 12
    },
    {
        word: "BACALHAU",
        clue: "Portuguese fish we never tried but made a song about",
        row: 0,
        col: 16,
        direction: "down",
        number: 13
    },
    {
        word: "DHAMAKA",
        clue: "Restaurant we went to for your first birthday together",
        row: 0,
        col: 18,
        direction: "down",
        number: 14
    },
    {
        word: "ALGARVE",
        clue: "South coast of Portugal where we enjoyed lots of beach time",
        row: 4,
        col: 15,
        direction: "across",
        number: 15
    },
    {
        word: "PANDAN",
        clue: "Your favorite Southeast Asian cocktail ingredient",
        row: 5,
        col: 27,
        direction: "down",
        number: 16
    },
    {
        word: "HUMMUS",
        clue: "Makes both of us bloated",
        row: 1,
        col: 18,
        direction: "across",
        number: 17
    },
    {
        word: "MONTY",
        clue: "Name of character I love picking in Mario Party that you hate",
        row: 8,
        col: 24,
        direction: "down",
        number: 18
    },
    {
        word: "TACOS",
        clue: "We ate so many of these in Mexico City",
        row: 8,
        col: 18,
        direction: "across",
        number: 19
    },
    {
        word: "CAVE",
        clue: "Cool formation we saw by boat in Algarve (Benagil ___)",
        row: 8,
        col: 20,
        direction: "down",
        number: 20
    },
    {
        word: "PEAS",
        clue: "What I said fell from the sky to start a conversation... and what actually did fall after our second date!",
        row: 9,
        col: 17,
        direction: "down",
        number: 21
    },
    {
        word: "COD",
        clue: "Portuguese fish (shorter name)",
        row: 9,
        col: 14,
        direction: "down",
        number: 22
    }
];

// Build the grid
let grid = [];
let cellMap = {};

function initializeGrid() {
    // Create empty grid
    for (let r = 0; r < GRID_ROWS; r++) {
        grid[r] = [];
        for (let c = 0; c < GRID_COLS; c++) {
            grid[r][c] = {
                letter: null,
                isBlocked: true,
                number: null,
                row: r,
                col: c,
                words: []
            };
        }
    }

    // Place words on grid
    words.forEach(wordData => {
        const { word, row, col, direction } = wordData;

        for (let i = 0; i < word.length; i++) {
            const r = direction === 'across' ? row : row + i;
            const c = direction === 'across' ? col + i : col;

            if (r < GRID_ROWS && c < GRID_COLS) {
                grid[r][c].letter = word[i];
                grid[r][c].isBlocked = false;
                grid[r][c].words.push(wordData);
                cellMap[`${r},${c}`] = grid[r][c];
            }
        }
    });

    // Assign numbers in reading order
    renumberCells();
}

function renumberCells() {
    let num = 1;
    const numberMap = {};

    for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
            const cell = grid[r][c];
            if (!cell.isBlocked) {
                const startsWord = cell.words.some(w => w.row === r && w.col === c);
                if (startsWord) {
                    cell.words.forEach(w => {
                        if (w.row === r && w.col === c) {
                            const key = `${w.word}-${w.direction}`;
                            if (!numberMap[key]) {
                                numberMap[key] = num;
                            }
                        }
                    });
                    cell.number = num;
                    num++;
                }
            }
        }
    }

    // Update word numbers
    words.forEach(w => {
        const key = `${w.word}-${w.direction}`;
        if (numberMap[key]) {
            w.number = numberMap[key];
        }
    });
}

function renderGrid() {
    const gridEl = document.getElementById('crossword-grid');
    gridEl.style.gridTemplateColumns = `repeat(${GRID_COLS}, var(--cell-size))`;
    gridEl.style.gridTemplateRows = `repeat(${GRID_ROWS}, var(--cell-size))`;
    gridEl.innerHTML = '';

    for (let r = 0; r < GRID_ROWS; r++) {
        for (let c = 0; c < GRID_COLS; c++) {
            const cell = grid[r][c];
            const cellEl = document.createElement('div');
            cellEl.className = 'cell';
            cellEl.dataset.row = r;
            cellEl.dataset.col = c;

            if (cell.isBlocked) {
                cellEl.classList.add('blocked');
            } else {
                if (cell.number) {
                    const numberEl = document.createElement('span');
                    numberEl.className = 'cell-number';
                    numberEl.textContent = cell.number;
                    cellEl.appendChild(numberEl);
                }

                const input = document.createElement('input');
                input.type = 'text';
                input.maxLength = 1;
                input.dataset.row = r;
                input.dataset.col = c;
                input.setAttribute('autocomplete', 'off');
                input.setAttribute('autocorrect', 'off');
                input.setAttribute('autocapitalize', 'characters');
                input.setAttribute('spellcheck', 'false');
                cellEl.appendChild(input);
            }

            gridEl.appendChild(cellEl);
        }
    }
}

function renderClues() {
    const acrossClues = document.getElementById('across-clues');
    const downClues = document.getElementById('down-clues');

    // Get unique words (some share the same number)
    const seenAcross = new Set();
    const seenDown = new Set();

    const acrossWords = words.filter(w => {
        if (w.direction === 'across' && !seenAcross.has(w.number)) {
            seenAcross.add(w.number);
            return true;
        }
        return false;
    }).sort((a, b) => {
        // Put WILLYOUBEMYVALENTINE last
        if (a.word === 'WILLYOUBEMYVALENTINE') return 1;
        if (b.word === 'WILLYOUBEMYVALENTINE') return -1;
        return a.number - b.number;
    });

    const downWords = words.filter(w => {
        if (w.direction === 'down' && !seenDown.has(w.number)) {
            seenDown.add(w.number);
            return true;
        }
        return false;
    }).sort((a, b) => a.number - b.number);

    acrossWords.forEach(wordData => {
        const li = document.createElement('li');
        li.dataset.number = wordData.number;
        li.dataset.direction = wordData.direction;
        li.innerHTML = `<span class="clue-number">${wordData.number}.</span> ${wordData.clue}`;
        li.addEventListener('click', () => selectWord(wordData));
        acrossClues.appendChild(li);
    });

    downWords.forEach(wordData => {
        const li = document.createElement('li');
        li.dataset.number = wordData.number;
        li.dataset.direction = wordData.direction;
        li.innerHTML = `<span class="clue-number">${wordData.number}.</span> ${wordData.clue}`;
        li.addEventListener('click', () => selectWord(wordData));
        downClues.appendChild(li);
    });
}

let currentDirection = 'across';
let currentWord = null;
let currentCell = null;

function selectWord(wordData) {
    currentWord = wordData;
    currentDirection = wordData.direction;

    const { row, col, word, direction } = wordData;
    let targetRow = row;
    let targetCol = col;

    for (let i = 0; i < word.length; i++) {
        const r = direction === 'across' ? row : row + i;
        const c = direction === 'across' ? col + i : col;
        const input = getInputAt(r, c);
        if (input && !input.value) {
            targetRow = r;
            targetCol = c;
            break;
        }
    }

    focusCell(targetRow, targetCol);
}

function getInputAt(row, col) {
    return document.querySelector(`input[data-row="${row}"][data-col="${col}"]`);
}

function focusCell(row, col) {
    const input = getInputAt(row, col);
    if (input) {
        input.focus();
        input.select();
        currentCell = { row, col };
        updateHighlights();
    }
}

function updateHighlights() {
    document.querySelectorAll('.cell').forEach(cell => {
        cell.classList.remove('active', 'active-word');
    });
    document.querySelectorAll('.clue-list li').forEach(li => {
        li.classList.remove('active');
    });

    if (!currentCell) return;

    const { row, col } = currentCell;
    const cell = grid[row][col];

    currentWord = cell.words.find(w => w.direction === currentDirection) || cell.words[0];
    if (currentWord) {
        currentDirection = currentWord.direction;
    }

    const activeCellEl = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
    if (activeCellEl) {
        activeCellEl.classList.add('active');
    }

    if (currentWord) {
        const { row: startRow, col: startCol, word, direction } = currentWord;
        for (let i = 0; i < word.length; i++) {
            const r = direction === 'across' ? startRow : startRow + i;
            const c = direction === 'across' ? startCol + i : startCol;
            const cellEl = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
            if (cellEl) {
                cellEl.classList.add('active-word');
            }
        }

        const clueEl = document.querySelector(`.clue-list li[data-number="${currentWord.number}"][data-direction="${currentWord.direction}"]`);
        if (clueEl) {
            clueEl.classList.add('active');
            clueEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
    }
}

function moveToNextCell() {
    if (!currentCell || !currentWord) return;

    const { row, col } = currentCell;
    const { direction } = currentWord;

    let nextRow = direction === 'across' ? row : row + 1;
    let nextCol = direction === 'across' ? col + 1 : col;

    const wordEndRow = currentWord.row + (direction === 'down' ? currentWord.word.length - 1 : 0);
    const wordEndCol = currentWord.col + (direction === 'across' ? currentWord.word.length - 1 : 0);

    if (nextRow <= wordEndRow && nextCol <= wordEndCol) {
        focusCell(nextRow, nextCol);
    }
}

function moveToPrevCell() {
    if (!currentCell || !currentWord) return;

    const { row, col } = currentCell;
    const { direction } = currentWord;

    let prevRow = direction === 'across' ? row : row - 1;
    let prevCol = direction === 'across' ? col - 1 : col;

    if (prevRow >= currentWord.row && prevCol >= currentWord.col) {
        focusCell(prevRow, prevCol);
    }
}

function toggleDirection() {
    if (!currentCell) return;

    const { row, col } = currentCell;
    const cell = grid[row][col];

    if (cell.words.length > 1) {
        currentDirection = currentDirection === 'across' ? 'down' : 'across';
        updateHighlights();
    }
}

function handleInput(e) {
    const input = e.target;
    const value = input.value.toUpperCase();

    if (value.length > 0) {
        input.value = value.slice(-1);
        moveToNextCell();
    }
}

function handleKeydown(e) {
    switch (e.key) {
        case 'ArrowRight':
            e.preventDefault();
            if (currentDirection === 'across') {
                moveToNextCell();
            } else {
                currentDirection = 'across';
                updateHighlights();
            }
            break;
        case 'ArrowLeft':
            e.preventDefault();
            if (currentDirection === 'across') {
                moveToPrevCell();
            } else {
                currentDirection = 'across';
                updateHighlights();
            }
            break;
        case 'ArrowDown':
            e.preventDefault();
            if (currentDirection === 'down') {
                moveToNextCell();
            } else {
                currentDirection = 'down';
                updateHighlights();
            }
            break;
        case 'ArrowUp':
            e.preventDefault();
            if (currentDirection === 'down') {
                moveToPrevCell();
            } else {
                currentDirection = 'down';
                updateHighlights();
            }
            break;
        case 'Tab':
            e.preventDefault();
            moveToNextWord();
            break;
        case 'Backspace':
            if (!e.target.value) {
                e.preventDefault();
                moveToPrevCell();
            }
            break;
        case ' ':
            e.preventDefault();
            toggleDirection();
            break;
    }
}

function moveToNextWord() {
    if (!currentWord) return;

    const sortedWords = [...words].sort((a, b) => {
        // Put WILLYOUBEMYVALENTINE last
        if (a.word === 'WILLYOUBEMYVALENTINE') return 1;
        if (b.word === 'WILLYOUBEMYVALENTINE') return -1;
        return a.number - b.number;
    });
    const currentIndex = sortedWords.findIndex(w => w.word === currentWord.word && w.direction === currentWord.direction);
    const nextIndex = (currentIndex + 1) % sortedWords.length;

    selectWord(sortedWords[nextIndex]);
}

function handleFocus(e) {
    const input = e.target;
    const row = parseInt(input.dataset.row);
    const col = parseInt(input.dataset.col);

    currentCell = { row, col };

    const cell = grid[row][col];
    if (!cell.words.find(w => w.direction === currentDirection)) {
        currentDirection = cell.words[0].direction;
    }

    updateHighlights();
}

function checkPuzzle() {
    let allCorrect = true;
    let allFilled = true;

    words.forEach(wordData => {
        const { word, row, col, direction } = wordData;

        for (let i = 0; i < word.length; i++) {
            const r = direction === 'across' ? row : row + i;
            const c = direction === 'across' ? col + i : col;
            const input = getInputAt(r, c);

            if (input) {
                if (!input.value) {
                    allFilled = false;
                } else if (input.value.toUpperCase() !== word[i]) {
                    allCorrect = false;
                }
            }
        }
    });

    if (!allFilled) {
        alert('Keep going! Some cells are still empty.');
        return;
    }

    if (allCorrect) {
        revealValentine();
    } else {
        alert('Almost there! Some answers are not quite right. Keep trying!');
    }
}

function revealValentine() {
    const overlay = document.getElementById('reveal-overlay');
    overlay.classList.remove('hidden');

    startFloatingHearts();

    if (typeof startConfetti === 'function') {
        startConfetti();
    }
}

function startFloatingHearts() {
    const container = document.getElementById('hearts-container');
    const hearts = ['ðŸ’•', 'ðŸ’–', 'ðŸ’—', 'ðŸ’', 'â¤ï¸', 'ðŸ’˜', 'ðŸ’“'];

    function createHeart() {
        const heart = document.createElement('div');
        heart.className = 'floating-heart';
        heart.textContent = hearts[Math.floor(Math.random() * hearts.length)];
        heart.style.left = Math.random() * 100 + 'vw';
        heart.style.animationDuration = (3 + Math.random() * 2) + 's';
        heart.style.fontSize = (1.5 + Math.random() * 1.5) + 'rem';
        container.appendChild(heart);

        setTimeout(() => heart.remove(), 5000);
    }

    setInterval(createHeart, 300);

    for (let i = 0; i < 10; i++) {
        setTimeout(createHeart, i * 100);
    }
}

function initEventListeners() {
    const gridEl = document.getElementById('crossword-grid');

    gridEl.addEventListener('input', handleInput);
    gridEl.addEventListener('keydown', handleKeydown);
    gridEl.addEventListener('focusin', handleFocus);

    document.getElementById('check-btn').addEventListener('click', checkPuzzle);
}

function init() {
    initializeGrid();
    renderGrid();
    renderClues();
    initEventListeners();

    // Debug: skip directly to reveal screen
    if (DEBUG_SHOW_REVEAL) {
        revealValentine();
        return;
    }

    // Select first word
    const firstWord = words.find(w => w.number === 1);
    if (firstWord) {
        selectWord(firstWord);
    }
}

document.addEventListener('DOMContentLoaded', init);
